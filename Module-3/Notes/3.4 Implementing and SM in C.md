Consider the following state diagram:
![[state 2 example.png]]

This can be implemented in a state machine such as:
```C
#include "RIMS.h"

enum LA_States { LA_SMStart, LA_s0, LA_s1 } LA_State;

void TickFct_Latch()
{
  switch(LA_State) {   // Transitions
     case LA_SMStart:  // Initial transition
        LA_State = LA_s0;
        break;

     case LA_s0:
        if (!A0) {
           LA_State = LA_s0;
        }
        else if (A0) {
           LA_State = LA_s1;
        }
        break;

     case LA_s1:
        if (!A0) {
           LA_State = LA_s0;
        }
        else if (A0) {
           LA_State = LA_s1;
        }
        break;

     default:
        LA_State = LA_SMStart;
        break;
  } // Transitions

  switch(LA_State) {   // State actions
     case LA_s0:
        break;

     case LA_s1:
        B0 = A1;
        break;

     default:
        break;
   } // State actions
}

void main() {
   B = 0x00;              // Initialize outputs
   LA_State = LA_SMStart; // Indicates initial call

   while(1) {
      TickFct_Latch();
   }
}
```

Some good practice is to start the tick by initializing all the outputs. This ensures that unintended results don't occur.

Notice that in this case that the only statement that iterates the ticks is `TickFct_Latch();`.

If there is a state that could be programed, it should be. Meaning that even if the action for that state is nothing. It should still be present because it best practice to demonstrate that it exists so another developer doesn't waste time understanding that nothing would've happened.

Just from working with a few of the state machines something has become apparent to me. The general architecture is an enumeration of all the states, a switch case to assign the current state, and a value assignment switch case depending on the state. You can see this in the example above, one enumeration and two switch cases. 