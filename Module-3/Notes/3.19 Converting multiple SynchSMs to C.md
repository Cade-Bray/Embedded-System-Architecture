Using the same technique as converting a single synchSM, described here [[3.15 Converting a SynchSM to C]], we can also convert multiple SynchSMs to C. For the example below assume that the two SynchSMs given have the same period of 1000ms. 

```C
#include "RIMS.h"

// LedShow C code, having two tasks

volatile unsigned char TimerFlag=0;

void TimerISR() {
   TimerFlag = 1;
}

enum BL_States { BL_SMStart, BL_LedOff, BL_LedOn } BL_State;
void TickFct_BlinkLed() {
   ... // Standard switch statements for SM
}
enum TL_States { TL_SMStart, TL_T0, TL_T1, TL_T2 } TL_State; 
void TickFct_ThreeLeds() {
   ... // Standard switch statements for SM
}

void main() {
   B = 0; // Init outputs
   TimerSet(1000);
   TimerOn(); 
   BL_State = BL_SMStart;
   TL_State = TL_SMStart; 
   while (1) {          
      TickFct_BlinkLed();    // Tick the BlinkLed synchSM
      TickFct_ThreeLeds();   // Tick the ThreeLeds synchSM
      while (!TimerFlag){}   // Wait for timer period
      TimerFlag = 0;         // Lower flag raised by timer
   }
}
```

Technically the `TickFct_ThreeLeds()` ticks slightly after `TickFct_BlinkLed()` because they're running in order not concurrently. They both still tick once per timer period but if you add to many tasks in each timer period you run the risk of ISR interrupting later defined tasks. This is common in computing is referred to as 'round-robin' or just multi-tasking.

You can even make other sequential code tasks that aren't time based a SynchSM and executed the same.