I learned about state machine in robotics which makes sense as we're taking advantage of embedded designs in robotics. Some general best practices is that a state machine should have an initial state as it enters its runtime, this is called the **current state**. Upon entering a state the code executes once until it finds its needed holding location to wait for a change. This initial execution is called a **tick** or **SM**. Consider the design constraints of your project. Consider a LED that needs to be lit. You'd want the current state first tick to take a negative case where it would default to not turning on the LED on its entrance.

When you leave a state in a state machine you should have **mutually exclusive** transition conditions. This means that only one condition could possibly be true at any given time. If you have multiple conditions that could move you from a state your machine becomes **non-deterministic** because it doesn't know what path it should take.

---

**Example of reading a timing and state diagram**
![[state example.png]]

![[timing example.png]]



| Time | State    |
| ---- | -------- |
| 0s   | Init     |
| 0.5s | WaitRise |
| 1s   | WaitFall |
| 1.5s | WaitRise |
At 4s the integer value of B is equal to 3. At 5s the integer value takes a reset and is now 0.

---

